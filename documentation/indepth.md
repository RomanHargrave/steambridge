# The short version

1. Configure with **make config**.  See common/settings.sh for more
information on how to change the configuration.
2. Copy *common/include/config.h* to Windows, if you are two different
machines.
3. Compile the Visual Studio solution (Release build).  Copy
*steam_api_proxy.dll* to the Linux tree.
4. Install g++ & multilib and a recent version of Wine & dev.
5. Compile the Winelib DLL using the provided *Makefile*.
6. Setup the SteamBridge environment with **make deploy** (no root/sudo).
Various tools are installed to *~/.steam/root/SteamBridge/bin*.
7. Download an application using *download.py*.  Various applications
won't download correctly.  Use the Windows native Steam client, and copy
the appmanifest file in *SteamApps* and the installation directory in
*SteamApps/common* to *~/.steam/root/SteamApps/* manually.  Eventually,
this will be handled through SteamBridge.
6. Configure the application using *configure.py*.
7. Execute the application using the newly .desktop file or *execute.py*.

# Windows Proxy DLL

The compilation spits out two DLLs: *steam_api_bridge.dll* and
*steam_api_proxy.dll*.  Bridge is a simple stub library that merely
implements the same API/symbols as the Linux Winelib library, necessary
for Proxy to have something to link against.

Proxy is a drop-in replacement for *steam_api.dll*.  Instead of
communicating with the Windows Steam client inside Wine, it communicates
with the Winelib Bridge. The Winelib Bridge, in turn, routes the API
calls to the native Linux Steam client.

Note that Proxy depends on the config.h generated by **make config**.
It only uses the Version and App-Name stuff, so it doesn't need to be kept
insync that aggressively.  At some point, this will be handled better.

# Linux Bridge Winelib library

Configure with **make config**.  This generates a few configuration files,
one for C++ code, the other for the Python runtime.  See
*common/settings.sh* for more information.

Compile with run **make**.  All, clean, rebuild, config, deploy, and
redeploy are implemented.  Deploy sets up the SteamBridge environment
inside your home directory.  Redeploy deletes the existing one and
then deploys.  As everything is contained within your home, root/sudo
access is not needed.

*steam_api_bridge.dll.so* is the compiled binary, a Winelib
library for use with Wine.  The SteamBridge deployment copies it to
*~/.steam/root/SteamBridge/*. 

# Deployment and execution notes

* Output is stored in ~/.steam/root/SteamBridge/appdb/[appid]/\*.txt.
* The built-in WINE Visual C+++ Runtime (2010, aka msvcp100.dll) works
  fine, outside a single specific scenario (so far).
* You can run Wine Steam applications through Steam Linux using Steam's
  "Add Non-Steam Game..." feature.  See the .desktop file created by
  Configure.
    * In my test setup, the built-in msvcp100.dll blows up inside its
      DllMain, possibly due to issues with establishing stdin/stdout.
      Installing the real DLL (winetricks vcrun2010) works right.
    * The Steam overlay loads (!) and works mostly correctly (!).
      Steam API calls impact the injected Overlay, interestingly.  Ethan:
      Meteor Hunter sets the corner of popups, and the Overlay obeys.
    * The content of the Overlay isn't tied to the appid.  It's
      generic links and content, unfortunately.
* Run time is properly recorded by Steam!
* *libsteam_api.so* is forward compatible, so long as newer APIs aren't
  used (which will crash, hopefully quickly).  The Source 1 SDK is behind
  the library used in Ethan Meteor Hunter, but it appears to run fine.
  My guess is as long as the application doesn't use any new API calls,
  the older library will work fine.

