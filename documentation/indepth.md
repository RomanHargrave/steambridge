# The short version

1. Configure with **make config**.  See *common/settings.sh* for more
information on how to change the configuration.
2. Copy *common/include/config.h* to Windows' *common/include/*.
3. Compile the Visual Studio solution (Release build).  Copy
*steam_api_proxy.dll* back to the Linux.  Doesn't matter where in the
source the DLL is placed, as long as there's only once copy.
4. Install *build-essential*, *g++*, *g++-multilib*, *wine1.7*, and
*wine1.7-dev*; or similar.
5. Compile the Winelib DLL by running **make**.
6. Setup the SteamBridge environment with **make deploy** (no root/sudo).
Various tools are installed to *~/.steam/root/SteamBridge/bin*.
7. Download an application using *download.py*.
  * Various applications won't download correctly, and you'll need
  to use the Windows native Steam client.  Copy the appmanifest file
  in *SteamApps* and the installation directory in *SteamApps/common*
  to *~/.steam/root/SteamApps/* manually.
6. Configure the application using *configure.py*.
7. Execute the application using the newly .desktop file or *execute.py*.
  * You can add this .desktop file back to Steam.  Note that it won't
    be imported 100% correctly, and you'll need to add the appid as a
    parameter to *execute.py*.

# Windows Proxy DLL

The compilation spits out two DLLs: *steam_api_bridge.dll* and
*steam_api_proxy.dll*.

The Bridge DLL is a simple stub library that implements the same symbols
as the Winelib library.  Proxy needs something to link against, and this
DLL is not usable outside of compilation.

Proxy is a drop-in replacement for *steam_api.dll*.  Instead of
communicating with the Windows Steam client inside Wine, it routes them
to the Linux *libsteam_api.dll*, using object pointers retrieved by the
Winelib Bridge.

Note that Proxy depends on the config.h generated by **make config**.
It only uses the Version and App-Name directives, so it doesn't need to be kept
very insync.  Eventually, this will be handled better.

# Linux Bridge Winelib library

Configure with **make config**.  This generates a few configuration files,
one for C++ code, the other for the Python runtime.  See
*common/settings.sh* for more information.

Compile with run **make**.  All, clean, rebuild, config, deploy, and
redeploy are implemented.  Deploy sets up the SteamBridge environment
inside your home directory.  Redeploy deletes the existing one and
then deploys.  As everything is contained within your home, root/sudo
access is not needed.

*steam_api_bridge.dll.so* is the compiled binary, a Winelib
library for use with Wine.  The SteamBridge deployment copies it to
*~/.steam/root/SteamBridge/*.

# Deployment and execution notes

* Output is stored in ~/.steam/root/SteamBridge/appdb/[appid]/\*.txt.
  * This is only for output generated by Wine.  Errors by the Python
    scripts themselves are not stored (yet).
* The built-in WINE Visual C+++ Runtime (2010, aka msvcp100.dll) works
  mostly fine.
  * In my test setup, it doesn't work when running a SteamBridge app
    through Linux Steam.  Seems to be an issue setting up stdin/stdout.
  * Install the real DLL using **winetricks vcrun2010**.  Replace
    vcrun2010 if you use a different version of Visual Studio.
* You can run Wine Steam applications through Steam Linux using Steam's
  "Add Non-Steam Game..." feature.  See the .desktop file created by
  Configure.
    * The Steam overlay loads (!) and works mostly correctly (!).
      Steam API calls impact the injected Overlay correctly.
    * The content of the Overlay isn't tied to the appid.  It's
      generic links and content, unfortunately.
* Run time is properly recorded by Steam!
* *libsteam_api.so* is forward compatible, so long as newer APIs aren't
  used (which will crash, hopefully quickly).  The Source 1 SDK is behind
  the library used in Ethan Meteor Hunter, but it appears to run fine.
  My guess is as long as the application doesn't use any new API calls,
  the older library will work fine.

