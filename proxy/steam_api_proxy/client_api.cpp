// client_api.cpp - Autogenerated source for ISteamClient
// Copyright (c) 2014 Bryan DeGrendel
//
// See COPYING and license/LICENSE.steambridge for license information

#include "stdafx.h"

#include "logging.h"
#include "state.h"
#include "steam_api_proxy.h"
#include "types.h"

#include "client_api.h"

#include <steam_api_bridge.h>

SteamClient::SteamClient() : steamClient(NULL)
{
  __TRACE("(this=0x%p)", this);
  steamClient = SteamClient_();
  __LOG("Wrapping ISteamClient (0x%p) into (0x%p)", steamClient, this);
}

HSteamPipe SteamClient::CreateSteamPipe()
{
  __TRACE("()");
  HSteamPipe result;
  __asm
  {
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+0]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, eax
    // restore stack
    // including this pointer
    pop eax
  }
  return result;
}

bool SteamClient::BReleaseSteamPipe(HSteamPipe hSteamPipe)
{
  __TRACE("(%i,)", hSteamPipe);
  bool result;
  __asm
  {
    // Push function arguments
    mov eax, hSteamPipe
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+4]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, al
    // restore stack
    // including this pointer
    pop eax
    pop eax
  }
  return result;
}

HSteamUser SteamClient::ConnectToGlobalUser(HSteamPipe hSteamPipe)
{
  __TRACE("(%i,)", hSteamPipe);
  HSteamUser result;
  __asm
  {
    // Push function arguments
    mov eax, hSteamPipe
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+8]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, eax
    // restore stack
    // including this pointer
    pop eax
    pop eax
  }
  return result;
}

HSteamUser SteamClient::CreateLocalUser(HSteamPipe *phSteamPipe, EAccountType eAccountType)
{
  __TRACE("(0x%p,%i,)", phSteamPipe, eAccountType);
  HSteamUser result;
  __asm
  {
    // Push function arguments
    mov eax, eAccountType
    push eax
    // Push function arguments
    mov eax, phSteamPipe
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+12]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, eax
    // restore stack
    // including this pointer
    pop eax
    pop eax
    pop eax
  }
  return result;
}

void SteamClient::ReleaseUser(HSteamPipe hSteamPipe, HSteamUser hUser)
{
  __TRACE("(%i,%i,)", hSteamPipe, hUser);
  __asm
  {
    // Push function arguments
    mov eax, hUser
    push eax
    // Push function arguments
    mov eax, hSteamPipe
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+16]
    // Call that memory location
    call eax
    // Move the returned value into the result
    // restore stack
    // including this pointer
    pop eax
    pop eax
    pop eax
  }
}

ISteamUser *SteamClient::GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion)

ISteamGameServer *SteamClient::GetISteamGameServer(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion)

void SteamClient::SetLocalIPBinding(uint32 unIP, uint16 usPort)
{
  __TRACE("(%u,%hu,)", unIP, usPort);
  __asm
  {
    // Push function arguments
    mov ax, usPort
    push eax
    // Push function arguments
    mov eax, unIP
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+28]
    // Call that memory location
    call eax
    // Move the returned value into the result
    // restore stack
    // including this pointer
    pop eax
    pop eax
    pop eax
  }
}

ISteamFriends *SteamClient::GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamUtils *SteamClient::GetISteamUtils(HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,\"%s\",)", hSteamPipe, pchVersion);

ISteamMatchmaking *SteamClient::GetISteamMatchmaking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamMatchmakingServers *SteamClient::GetISteamMatchmakingServers(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

// Not sure what this guy is
void *SteamClient::GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamUserStats *SteamClient::GetISteamUserStats(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamGameServerStats *SteamClient::GetISteamGameServerStats(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamuser, hSteamPipe, pchVersion);

ISteamApps *SteamClient::GetISteamApps(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamNetworking *SteamClient::GetISteamNetworking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamUser, hSteamPipe, pchVersion);

ISteamRemoteStorage *SteamClient::GetISteamRemoteStorage(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamuser, hSteamPipe, pchVersion);

ISteamScreenshots *SteamClient::GetISteamScreenshots(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamuser, hSteamPipe, pchVersion);

void SteamClient::RunFrame()
{
  __TRACE("()");
  __asm
  {
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+76]
    // Call that memory location
    call eax
    // Move the returned value into the result
    // restore stack
    // including this pointer
    pop eax
  }
}

uint32 SteamClient::GetIPCCallCount()
{
  __TRACE("()");
  uint32 result;
  __asm
  {
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+80]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, eax
    // restore stack
    // including this pointer
    pop eax
  }
  return result;
}

void SteamClient::SetWarningMessageHook(SteamAPIWarningMessageHook_t pFunction)
{
  __TRACE("(0x%p,)", pFunction);
  __asm
  {
    // Push function arguments
    mov eax, pFunction
    push eax
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+84]
    // Call that memory location
    call eax
    // Move the returned value into the result
    // restore stack
    // including this pointer
    pop eax
    pop eax
  }
}

bool SteamClient::BShutdownIfAllPipesClosed()
{
  __TRACE("()");
  bool result;
  __asm
  {
    // Push Linux-side 'this'
    mov eax, [this]
    mov eax, [eax]this.steamClient
    push eax
    // Get the vtable (pointer at this)
    mov eax, [eax]
    // Lookup the pointer in the vtable
    mov eax, [eax+88]
    // Call that memory location
    call eax
    // Move the returned value into the result
    mov result, al
    // restore stack
    // including this pointer
    pop eax
  }
  return result;
}

ISteamHTTP *SteamClient::GetISteamHTTP(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamuser, hSteamPipe, pchVersion);

ISteamUnifiedMessages *SteamClient::GetISteamUnifiedMessages(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion)
  __STUB("(%i,%i,\"%s\",)", hSteamuser, hSteamPipe, pchVersion);

#include "client_api_code.inc"

